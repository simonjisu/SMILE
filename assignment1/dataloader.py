import tensorflow as tf
import tensorflow_datasets as tfds
import matplotlib.pyplot as plt
import numpy as np
from pathlib import Path

class DataLoader(object):
    def __init__(self, data_type:str='train', n_way:int=5, n_support:int=5, n_query:int=5):
        self.data_dir = Path('./data/')
        self.data_type = data_type
        self.data = self.preprocess_data(tfds.load("omniglot", split=self.data_type, data_dir=self.data_dir, as_supervised=True))
        
        self.n_way = n_way
        self.n_support = n_support
        self.n_query = n_query
        self.task_list = None
        
        
    def preprocess_data(self, dataset):
        print(f"Preprocessing {self.data_type} Omniglot dataset")
        def preprocess(image, label):
            image = tf.image.convert_image_dtype(image, tf.float32)
            image = tf.image.rgb_to_grayscale(image)
            image = tf.image.resize(image, [28,28])
            return image, label

        data = {}
        for image, label in dataset.map(preprocess):
            image = image.numpy()
            label = str(label.numpy())
            if label not in data:
                data[label] = []
            data[label].append(image)
        print("Finished preprocessing")
        return data
        
    def generate_task_list(self, n_tasks:int=100, n_way:int=0, n_query:int=0, n_support:int=0):
        n_way = self.n_way if n_way == 0 else n_way
        n_query = self.n_query if n_query == 0 else n_query
        n_support = self.n_support if n_support == 0 else n_support
        task_list = list()
        ############### Your code here ###################
            # TODO: finish implementing this method.
            # Append n_tasks number of tasks to task_list
            # where each task is a dictionary in the form of
            # {label: [random sequence]}
            # Hint: the keys of self.data can be used as labels

        for _ in range(n_tasks):
            task = {}
            labels = np.random.choice(list(self.data.keys()), n_way, replace=False)
            for label in labels:
                idxes = np.arange(len(self.data[label]))
                idxes = np.random.choice(idxes, n_query+n_support, replace=False)
                task[label] = idxes
            task_list.append(task)

        ##################################################
        
        self.task_list = task_list
        
    def delete_task_list(self):
        self.task_list = None
    
    def visualize_random_task(self):
        s, _ = self.data_generator()

        for img in s:
            fig, axs = plt.subplots(1, self.n_support, figsize=(self.n_support, self.n_way))
            for i in range(self.n_support):
                axs[i].imshow(img[i], cmap='gray')
                axs[i].axis('off')

        plt.show()
    
    def data_generator(self, task_idx=0):       
        if self.task_list != None:
            # Deterministic task from predefined task space
            assert(task_idx >= 0)
            task = self.task_list[task_idx]
        else:
            self.generate_task_list(n_tasks=1)
            task = self.task_list[0]
            self.delete_task_list()
    
        
        support = np.zeros([self.n_way, self.n_support, 28, 28, 1], dtype=np.float32)
        query = np.zeros([self.n_way, self.n_query, 28, 28, 1], dtype=np.float32)

        ############### Your code here ###################
            # TODO: finish implementing this method.
            # Using a task generated by generate_task_list,
            # create a support and query dataset with shapes
            # (n_way, n_support/n_query, 28, 28, 1)

        for i, (label, idxes) in enumerate(task.items()):
            data = [self.data[label][idx] for idx in idxes]
            support[i, :] = np.array(data[:self.n_support])
            query[i, :] = np.array(data[self.n_support:])

        ##################################################

        return support, query

    def random_data_generator(self):
        n_ways = [2, 3, 5, 6, 10, 15]
        n_shots = [15, 10, 6, 5, 3, 2]
        
        n_way = 0
        n_support = 0
        n_query = 0
        
        ############### Your code here ###################
            # TODO: Find numbers for n_way, n_support, n_query
            # where n_way * (n_support + n_query) == 30

        n_way = np.random.choice(n_ways, 1, replace=False)[0]
        idx = n_ways.index(n_way)
        n_shot = n_shots[idx]
        n_support = np.random.randint(1, n_shot)
        n_query = n_shot - n_support
        # print(f'{n_way}way-{n_shot}shot: sup {n_support} / que {n_query}')
        ##################################################

        assert(n_way * (n_support + n_query) == 30)
        
        # Generate a random task
        self.generate_task_list(n_tasks=1, n_way=n_way, n_support=n_support, n_query=n_query)
        task = self.task_list[0]
        self.delete_task_list()
        
        support = np.zeros([n_way, n_support, 28, 28, 1], dtype=np.float32)
        query = np.zeros([n_way, n_query, 28, 28, 1], dtype=np.float32)
        
        ############### Your code here ###################
            # TODO: finish implementing this method.
            # create a support and query dataset with shapes
            # (n_way, n_support/n_query, 28, 28, 1)
            # (Same as in the data_generator method)
        for i, (label, idxes) in enumerate(task.items()):
            data = [self.data[label][idx] for idx in idxes]
            support[i, :] = np.array(data[:n_support])
            query[i, :] = np.array(data[n_support:])
        ##################################################
        
        return support, query